Section.
Program = [Section].

eval p: Program => Bool.

// A section head must have at least one statement; a section body
// can be empty.

section head: Head, body: Body, #head > 0 => Section.

Head = [Comment + Declaration + Alias].
Body = [Comment + Expression].
(Comment, Declaration, Alias, Expression) = [String].
---
eval p <-> all sect <: p => is_all_bound? sect.

;

is_all_bound? sect: Section => Bool.
---

// All variables referred to in a section head must be defined by
// the end of that section head. All the variables in a section
// body, however, must be defined by the end of the *next* section
// body.

is_all_bound? sect <->
    all h <: head_of sect => all head_sym <: h => is_bound? head_sym
    and
    all b <: body_of (p (p sect - 1)) => all body_sym <: b => is_bound? body_sym.

;

head_of sect:Section => Head.
body_of sect:Section => Body.

is_bound? sym: String => Bool.
---

is_bound? sym <-> (sym in (env p) (p sect)) or (sym in base_env).

;

env p: Program => [Scope].
base_env => Scope.
Scope = {String}.
---
